// SPDX-License-Identifier: AGPL-3.0-or-later
#ifndef CGDEV_SOURCE_GPU_PRIVATE_VULKAN__VKN_STATUS_H
#define CGDEV_SOURCE_GPU_PRIVATE_VULKAN__VKN_STATUS_H
////////////////////////////////////////////////////////////////
// секция форвард-декларации
////////////////////////////////////////////////////////////////
#include "_wvk.h"
////////////////////////////////////////////////////////////////
// секция имплементации
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция родительского класса
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// секция для остального
////////////////////////////////////////////////////////////////

namespace CGDev {

	//namespace GPU {

		//namespace Private {

			namespace wvk {

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				enum class VknStatusCode {
					UNKNOWN = 0,

					SUCCESSFUL = 1,
					FAIL = 2,
					ALREADY_INITIALIZED = 3,
					CREATE_INFO_NULL_FIELD = 4,
					CREATE_INFO_INCOMPATIBLE_OBJECTS = 5,
					FEATURE_NOT_ENABLED = 6,
					CREATE_INFO_NO_VALID = 7,
					VKN_PHYSICAL_DEVICE_FAIL = 8				
				};





				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				class WvkStatus {

				public:

					VknStatusCode m_code;
					
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus(void) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus(const VknStatusCode& code) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline ~WvkStatus(void) noexcept;

				// hpp
				public:

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Возвращает указатель на накопленное сообщение статуса.
					*
					* Метод предоставляет доступ к внутреннему C-строковому буферу (`char[]`),
					* содержащему отладочное или диагностическое сообщение. Возвращаемый указатель
					* остаётся валидным до тех пор, пока объект `VknStatus` не будет модифицирован.
					*
					* @return const char*
					*         Указатель на null-терминированную строку с сообщением.
					*
					* @note Метод не вызывает исключений (noexcept) и не изменяет состояние объекта.
					*
					* @warning Возвращаемый указатель не следует изменять вручную.
					*
					* @code
					* WvkStatus status;
					* status.appendf("Инициализация завершилась с ошибкой: код %d", -1);
					* std::cout << status.getMessage() << std::endl;
					* // Вывод: Инициализация завершилась с ошибкой: код -1
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline bool isOk(void) const noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Проверка, является ли статус успешным.
					*
					* Метод позволяет использовать объект VknStatus в логических выражениях.
					* Например: if (status) { ... }.
					*
					* @return true, если статус SUCCESSFUL, иначе false.
					*
					* @code
					* WvkStatus status;
					* if (status) {
					*     // Всё хорошо
					* } else {
					*     std::cerr << status.getMessage();
					* }
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline operator bool(void) const noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief 
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline const VknStatusCode& getCode(void) const noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Возвращает указатель на накопленное сообщение статуса.
					* 
					* Метод предоставляет доступ к внутреннему C-строковому буферу (`char[]`), 
					* содержащему отладочное или диагностическое сообщение. Возвращаемый указатель 
					* остаётся валидным до тех пор, пока объект `VknStatus` не будет модифицирован.
					*
					* @return const char*  
					*         Указатель на null-терминированную строку с сообщением.
					*
					* @note Метод не вызывает исключений (noexcept) и не изменяет состояние объекта.
					*
					* @warning Возвращаемый указатель не следует изменять вручную.
					*
					* @code
					* WvkStatus status;
					* status.appendf("Инициализация завершилась с ошибкой: код %d", -1);
					* std::cout << status.getMessage() << std::endl;
					* // Вывод: Инициализация завершилась с ошибкой: код -1
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline const char* getMessage(void) const noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Возвращает текущую длину накопленного сообщения статуса.
					* 
					* Метод предоставляет длину уже записанного текста в лог-буфере. 
					* Это может быть полезно для отладки, логирования или контроля объёма данных.
					*
					* @return size_t 
					*         Количество байт (символов), записанных в лог-буфер.
					*
					* @note Метод не вызывает исключений (noexcept) и не изменяет состояние объекта.
					*
					* @code
					* WvkStatus status;
					* status.appendf("Ошибка в %s", "инициализации");
					* size_t length = status.getLength(); // например, 23
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline size_t getLength(void) const noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Устанавливает код статуса и добавляет форматированное сообщение.
					*
					* Метод позволяет задать новый код ошибки (если он не `SUCCESSFUL`) и дополнить сообщение
					* диагностическим текстом в формате `printf`.
					*
					* @param [in] code Новый код статуса (из enum VknStatusCode).
					* @param [in] fmt  Форматированная строка (`printf`-подобный формат). Может быть nullptr.
					* @param [in] ...  Переменное число аргументов, соответствующих `fmt`.
					*
					* @details
					* Метод полезен для установки кода ошибки и одновременно добавления сообщения.
					* Если `code` равен `VknStatusCode::SUCCESSFUL`, значение `m_code` не будет изменено —
					* это предотвращает затирание предыдущего статуса об ошибке. Если `fmt` не передан,
					* сообщение не добавляется.
					*
					* @note Метод безопасен (noexcept), но предполагает корректные аргументы `fmt` и ....
					*
					* @code
					* WvkStatus status;
					* status.set(VknStatusCode::CREATE_INFO_NO_VALID, "CreateInfo::log = nullptr");
					* std::cout << status.getMessage(); // Вывод: CreateInfo::log = nullptr
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& set(VknStatusCode code, const char* fmt = nullptr, ...) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& set(VknStatusCode code, const char* fmt, va_list args) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief Добавляет форматированную строку в сообщение.
					*
					* Этот метод использует безопасную версию `vsnprintf_s`, чтобы добавить форматированную строку
					* в сообщение, проверяя доступное место в буфере и обрезая строку при необходимости.
					*
					* @param fmt Форматированная строка (как в `printf`), в которую будут подставлены аргументы.
					* @param ... Аргументы, которые будут подставлены в строку согласно формату.
					*
					* @details
					* Метод безопасно добавляет данные в строку, проверяя, что не происходит переполнения буфера.
					* Если доступного места недостаточно, строка будет обрезана. После успешного добавления строки,
					* метод обновляет длину текущего сообщения.
					*
					* @code
					* // Пример использования:
					* append("Error code: %d", errorCode);
					* append("Loaded %s at %d", fileName, lineNumber);
					* @endcode
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& append(const char* fmt, ...) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& setOk(void) noexcept;	

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& setFail(const char* fmt = nullptr, ...) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					inline WvkStatus& operator << (const char* fmt) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					template <typename T>
					WvkStatus& operator << (const T& value) noexcept {
						std::ostringstream oss;
						oss << value;
						return append(oss.str().c_str());
					}

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					friend constexpr bool operator==(const WvkStatus& lhs, VknStatusCode rhs) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					friend constexpr bool operator==(VknStatusCode lhs, const WvkStatus& rhs) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					friend constexpr bool operator!=(const WvkStatus& lhs, VknStatusCode rhs) noexcept;

					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					/*!	\brief
					*/
					//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					friend constexpr bool operator!=(VknStatusCode lhs, const WvkStatus& rhs) noexcept;

				private:

				private:

					size_t m_length = 0;
					//char m_message[409600] = "";
					std::string m_message;

				}; // class WvkStatus

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				constexpr bool operator==(const WvkStatus& lhs, VknStatusCode rhs) noexcept {
					return lhs.m_code == rhs;
				}

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				constexpr bool operator==(VknStatusCode lhs, const WvkStatus& rhs) noexcept {
					return lhs == rhs.m_code;
				}

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				constexpr bool operator!=(const WvkStatus& lhs, VknStatusCode rhs) noexcept {
					return !(lhs == rhs);
				}

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				/*!	\brief
				*/
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				constexpr bool operator!=(VknStatusCode lhs, const WvkStatus& rhs) noexcept {
					return !(lhs == rhs);
				}

			} // namespace wvk

		//} // namespace Private

	//} // namespace GPU

} // namespace CGDev

#include "wvk_status.hpp"

#endif // CGDEV_SOURCE_GPU_PRIVATE_VULKAN__VKN_STATUS_H
