////////////////////////////////////////////////////////////////
// секция форвард-декларации
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция заголовочного файла
////////////////////////////////////////////////////////////////
#include "vkn_status_test.h"
////////////////////////////////////////////////////////////////
// секция имплементации
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция для остального
////////////////////////////////////////////////////////////////

namespace CGDev {

	namespace Tests {

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Тест:
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		TEST_F(VknStatusTest, Append) {
			m_status.append("Test:\n\t%s - string\n\t%d - integer", "TestString", 5);
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Тест: Проверка, что переполнение буфера не приводит к выходу за пределы
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		TEST_F(VknStatusTest, DoesNotOverflowBuffer) {
			// Создаём строку длиной ~5000 символов
			std::string long_str(5000, 'A');

			m_status.append("%s", long_str.c_str());

			// Проверяем, что буфер не вышел за пределы
			const char* msg = m_status.getMessage();
			EXPECT_EQ(msg[4095], '\0');  // Последний символ — всегда '\0'

			// Убедимся, что строка не длиннее буфера
			EXPECT_LE(strlen(msg), 4095);

			// Можем также убедиться, что строка выглядит как обрезанная
			EXPECT_TRUE(strncmp(msg, "AAAA", 4) == 0);  // Начало совпадает
		}

	} // namespace Tests

} // namespace CGDev